# ProjectileMissileDefense

The control loop calls the determineSafeSpots function. The entire width of the game space is divided into 200 cell array named W, that can be accessed by all functions of controller.cpp. 
1. The function determineSafeSpots initialises the W matrix as all ones(assuming all are safe initially).  It gets the projectiles using g.getProjectiles. It iterates through the list of projectiles and calls the trackProjectile function, that returns the expected time until impact and position of impact of the respective projectile. All projectiles that’ll hit after 15 units of time is ignored. For the others who will hit within 15 units of time, ceil(explosionSize) number of cells on either side are marked as not safe(value=0). Similarly, all current explosions are obtained using g.getExplosions(). The list is iterated through and  ceil(explosionSize) number of cells on either side of the position of explosion are marked not safe. Thus this function updates the array.
2. The trackProjectile function receives a projectile and the game as input and returns its predicted time and position of impact. The time and position of impact are obtained by solving the kinematics equations of a projectile as follows:
* v2 - u2 = 2* g.getGravity() *S
* v = u + g.getGravity() *t
* S = ut + ½*g.getGravity()*t2
3. Now the function pickSafeSpot examines the updated array and decides if the AI should move right or left. For this, it considers two cases, ie, if the agent is standing on a safe spot or a danger spot at the moment. In the first case, it calculates the number of safe spots until the nearest danger on both the right and left of the agent, ie, searches the array from the position of the agent until the cloest danger on either side and calculates variable ‘left’ and ‘right’. Then, it greedily decided to move in the direction which promises a longer safe area(higher number of continuous safe spots), ie away from pedicted and present dangers. If the agent is standing on a danger spot(that is, it will be hit within the next 15 time units if it doesn’t move), then the search calculates safe spots starting from the end of danger zone on each end and moves the agent in the direction which promises larger number of continuous safe spots. In the event of safe areas on either side being of equal size, the agent only moves if it is already standing in a danger spot. The code also checks if end of array is reached during search and discounts for that edge case. 
4. Based on the decision taken by the pickSafeSpot, it returns a value to the control function, -1 for left, +1 for right, and 0 for standstill. The control function updates the position of the agent as required.
